import { describe, it, beforeEach, mock } from "node:test";
import assert from "node:assert";
import { McpError, ErrorCode } from "@modelcontextprotocol/sdk/types.js";

// Import the tools to be tested
import { mcpConnectToServerTool } from "../../../src/tools/mcpConnectToServerTool.js";
import { mcpListServerToolsTool } from "../../../src/tools/mcpListServerToolsTool.js";
import { mcpCallServerTool } from "../../../src/tools/mcpCallServerTool.js";
import { mcpDisconnectFromServerTool } from "../../../src/tools/mcpDisconnectFromServerTool.js";
import { writeToFileTool } from "../../../src/tools/writeToFileTool.js";

// Import relevant constants/types for testing
import { TOOL_NAME as CONNECT_TOOL_NAME } from "../../../src/tools/mcpConnectToServerToolParams.js";
import { TOOL_NAME as LIST_TOOLS_TOOL_NAME } from "../../../src/tools/mcpListServerToolsToolParams.js";
import { TOOL_NAME as CALL_TOOL_TOOL_NAME } from "../../../src/tools/mcpCallServerToolParams.js";
import { TOOL_NAME as DISCONNECT_TOOL_NAME } from "../../../src/tools/mcpDisconnectFromServerToolParams.js";
import { TOOL_NAME as WRITE_FILE_TOOL_NAME } from "../../../src/tools/writeToFileToolParams.js";

// Import the dependencies to mock
import * as loggerModule from "../../../src/utils/logger.js";
import * as fileUtilsModule from "../../../src/utils/fileUtils.js";
import { ConfigurationManager } from "../../../src/config/ConfigurationManager.js";

// Create mock objects
const mockLogger = {
  info: mock.fn(),
  warn: mock.fn(),
  error: mock.fn(),
  debug: mock.fn()
};

const mockSecureWriteFile = mock.fn();

describe("MCP Client Tools Unit Tests", () => {
  // Common mocks shared across tests
  interface MockMcpServer {
    tool: ReturnType<typeof mock.fn>;
  }

  interface MockMcpClientService {
    connectSse: ReturnType<typeof mock.fn>;
    connectStdio: ReturnType<typeof mock.fn>;
    listTools: ReturnType<typeof mock.fn>;
    callTool: ReturnType<typeof mock.fn>;
    closeSseConnection: ReturnType<typeof mock.fn>;
    closeStdioConnection: ReturnType<typeof mock.fn>;
  }

  interface MockConfigManager {
    getInstance: ReturnType<typeof mock.fn>;
  }

  let mockMcpServer: MockMcpServer;
  let mockMcpClientService: MockMcpClientService;
  let mockConfigurationManager: MockConfigManager;
  
  // Function to create and capture the processor function
  const captureProcessorFunction = (mock: MockMcpServer): Function => {
    assert.strictEqual(mock.tool.mock.callCount(), 1, "Tool should be registered exactly once");
    const calls = mock.tool.mock.calls;
    const processorFunction = calls[0].arguments[3];
    assert.strictEqual(typeof processorFunction, "function", "Processor function should be a function");
    return processorFunction;
  };

  beforeEach(() => {
    // Reset all mocks
    if (mockMcpServer) {
      mockMcpServer.tool.mock.resetCalls();
    }
    
    // Create fresh mocks for each test
    mockMcpServer = {
      tool: mock.fn(),
    };
    
    mockMcpClientService = {
      connectSse: mock.fn().mockResolvedValue("test-sse-connection-id"),
      connectStdio: mock.fn().mockResolvedValue("test-stdio-connection-id"),
      listTools: mock.fn().mockResolvedValue([
        { name: "tool1", description: "Test Tool 1", parametersSchema: {} },
        { name: "tool2", description: "Test Tool 2", parametersSchema: {} },
      ]),
      callTool: mock.fn().mockResolvedValue({ result: "Tool execution result" }),
      closeSseConnection: mock.fn().mockReturnValue(false), // Default to false, override in specific tests
      closeStdioConnection: mock.fn().mockReturnValue(false), // Default to false, override in specific tests
    };
    
    // Mock ConfigurationManager
    mockConfigurationManager = {
      getInstance: mock.fn().mockReturnValue({
        getMcpConfig: mock.fn().mockReturnValue({
          clientId: "test-client-id",
          connectionToken: "test-connection-token",
          host: "localhost",
          port: 8080,
          logLevel: "info",
          transport: "stdio",
        }),
        getAllowedOutputPaths: mock.fn().mockReturnValue(["/allowed/path"]),
      }),
    };

    // Reset secureWriteFile mock
    mockSecureWriteFile.mock.resetCalls();
    mockSecureWriteFile.mockResolvedValue(undefined);
    
    // Apply mocks
    // Mock the logger module
    Object.defineProperty(loggerModule, "logger", {
      value: mockLogger,
      configurable: true
    });
    
    // Mock the fileUtils module
    Object.defineProperty(fileUtilsModule, "secureWriteFile", {
      value: mockSecureWriteFile,
      configurable: true
    });
    
    // Mock the ConfigurationManager
    Object.defineProperty(ConfigurationManager, "getInstance", {
      value: mockConfigurationManager.getInstance,
      configurable: true
    });
  });

  describe("mcpConnectToServerTool", () => {
    it("should register the tool with the MCP server", () => {
      // Register the tool
      mcpConnectToServerTool(mockMcpServer, mockMcpClientService);
      
      // Verify registration
      assert.strictEqual(mockMcpServer.tool.mock.callCount(), 1);
      const [name, description, schema, processor] = mockMcpServer.tool.mock.calls[0].arguments;
      assert.strictEqual(name, CONNECT_TOOL_NAME);
      assert.ok(description.length > 0);
      assert.ok(schema);
      assert.strictEqual(typeof processor, "function");
    });
    
    it("should connect to SSE server successfully", async () => {
      // Register the tool
      mcpConnectToServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        transport: "sse",
        connectionDetails: {
          transport: "sse",
          url: "https://example.com/sse",
          clientId: "custom-client-id",
          connectionToken: "custom-connection-token",
        },
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify connectSse was called
      assert.strictEqual(mockMcpClientService.connectSse.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.connectSse.mock.calls[0].arguments[0], "https://example.com/sse");
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({ connectionId: "test-sse-connection-id" }, null, 2),
          },
        ],
      });
    });
    
    it("should connect to stdio server successfully", async () => {
      // Register the tool
      mcpConnectToServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        transport: "stdio",
        connectionDetails: {
          transport: "stdio",
          command: "test-command",
          args: ["arg1", "arg2"],
          clientId: "custom-client-id",
          connectionToken: "custom-connection-token",
        },
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify connectStdio was called
      assert.strictEqual(mockMcpClientService.connectStdio.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.connectStdio.mock.calls[0].arguments[0], "test-command");
      assert.deepStrictEqual(mockMcpClientService.connectStdio.mock.calls[0].arguments[1], ["arg1", "arg2"]);
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({ connectionId: "test-stdio-connection-id" }, null, 2),
          },
        ],
      });
    });
    
    it("should use default values from ConfigurationManager if not provided", async () => {
      // Register the tool
      mcpConnectToServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments without clientId and connectionToken
      const args = {
        transport: "stdio",
        connectionDetails: {
          transport: "stdio",
          command: "test-command",
        },
      };
      
      // Call the processor function
      await processor(args);
      
      // Verify ConfigurationManager.getInstance().getMcpConfig() was called
      assert.strictEqual(mockConfigurationManager.getInstance.mock.callCount(), 1);
      assert.strictEqual(
        mockConfigurationManager.getInstance().getMcpConfig.mock.callCount(), 
        1
      );
    });
    
    it("should handle SSE connection errors", async () => {
      // Register the tool
      mcpConnectToServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock connectSse to throw an error
      mockMcpClientService.connectSse.mockRejectedValue(
        new Error("Connection failed")
      );
      
      // Create test arguments
      const args = {
        transport: "sse",
        connectionDetails: {
          transport: "sse",
          url: "https://example.com/sse",
        },
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InternalError);
          assert.ok(mcpError.message.includes("Connection failed"));
          return true;
        }
      );
    });
  });
  
  describe("mcpListServerToolsTool", () => {
    it("should register the tool with the MCP server", () => {
      // Register the tool
      mcpListServerToolsTool(mockMcpServer, mockMcpClientService);
      
      // Verify registration
      assert.strictEqual(mockMcpServer.tool.mock.callCount(), 1);
      const [name, description, schema, processor] = mockMcpServer.tool.mock.calls[0].arguments;
      assert.strictEqual(name, LIST_TOOLS_TOOL_NAME);
      assert.ok(description.length > 0);
      assert.ok(schema);
      assert.strictEqual(typeof processor, "function");
    });
    
    it("should list tools from a valid connection", async () => {
      // Register the tool
      mcpListServerToolsTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        connectionId: "test-connection-id",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify listTools was called
      assert.strictEqual(mockMcpClientService.listTools.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.listTools.mock.calls[0].arguments[0], "test-connection-id");
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify([
              { name: "tool1", description: "Test Tool 1", parametersSchema: {} },
              { name: "tool2", description: "Test Tool 2", parametersSchema: {} },
            ], null, 2),
          },
        ],
      });
    });
    
    it("should handle non-existent connection", async () => {
      // Register the tool
      mcpListServerToolsTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock listTools to throw a specific error
      mockMcpClientService.listTools.mockRejectedValue(
        new Error("No connection found with ID non-existent-id")
      );
      
      // Create test arguments
      const args = {
        connectionId: "non-existent-id",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidParams);
          assert.ok(error.message.includes("Invalid or non-existent connection ID"));
          return true;
        }
      );
    });
    
    it("should handle other errors", async () => {
      // Register the tool
      mcpListServerToolsTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock listTools to throw a generic error
      mockMcpClientService.listTools.mockRejectedValue(
        new Error("Some other error")
      );
      
      // Create test arguments
      const args = {
        connectionId: "test-connection-id",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InternalError);
          assert.ok(error.message.includes("Some other error"));
          return true;
        }
      );
    });
  });
  
  describe("mcpCallServerTool", () => {
    it("should register the tool with the MCP server", () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Verify registration
      assert.strictEqual(mockMcpServer.tool.mock.callCount(), 1);
      const [name, description, schema, processor] = mockMcpServer.tool.mock.calls[0].arguments;
      assert.strictEqual(name, CALL_TOOL_TOOL_NAME);
      assert.ok(description.length > 0);
      assert.ok(schema);
      assert.strictEqual(typeof processor, "function");
    });
    
    it("should call a tool on a remote server", async () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        connectionId: "test-connection-id",
        toolName: "remote-tool",
        toolParameters: { param1: "value1", param2: 123 },
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify callTool was called
      assert.strictEqual(mockMcpClientService.callTool.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.callTool.mock.calls[0].arguments[0], "test-connection-id");
      assert.strictEqual(mockMcpClientService.callTool.mock.calls[0].arguments[1], "remote-tool");
      assert.deepStrictEqual(mockMcpClientService.callTool.mock.calls[0].arguments[2], { param1: "value1", param2: 123 });
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({ result: "Tool execution result" }, null, 2),
          },
        ],
      });
    });
    
    it("should write output to file when outputFilePath is provided", async () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments with outputFilePath
      const args = {
        connectionId: "test-connection-id",
        toolName: "remote-tool",
        toolParameters: { param1: "value1" },
        outputFilePath: "/allowed/path/output.json",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify callTool was called
      assert.strictEqual(mockMcpClientService.callTool.mock.callCount(), 1);
      
      // Verify secureWriteFile was called
      assert.strictEqual(mockSecureWriteFile.mock.callCount(), 1);
      assert.strictEqual(mockSecureWriteFile.mock.calls[0].arguments[0], "/allowed/path/output.json");
      assert.strictEqual(
        mockSecureWriteFile.mock.calls[0].arguments[1], 
        JSON.stringify({ result: "Tool execution result" }, null, 2)
      );
      
      // Verify result contains file path info
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              message: "Output written to file",
              filePath: "/allowed/path/output.json",
            }, null, 2),
          },
        ],
      });
    });
    
    it("should throw error when no allowed output paths are configured", async () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock getAllowedOutputPaths to return empty array
      mockConfigurationManager.getInstance().getAllowedOutputPaths.mockReturnValue([]);
      
      // Create test arguments with outputFilePath
      const args = {
        connectionId: "test-connection-id",
        toolName: "remote-tool",
        toolParameters: { param1: "value1" },
        outputFilePath: "/path/to/output.json",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidRequest);
          assert.ok(error.message.includes("No allowed output paths configured"));
          return true;
        }
      );
    });
    
    it("should handle secureWriteFile errors", async () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock secureWriteFile to throw
      mockSecureWriteFile.mockRejectedValue(
        new Error("Permission denied")
      );
      
      // Create test arguments with outputFilePath
      const args = {
        connectionId: "test-connection-id",
        toolName: "remote-tool",
        toolParameters: { param1: "value1" },
        outputFilePath: "/allowed/path/output.json",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidRequest);
          assert.ok(error.message.includes("Failed to write output to file"));
          return true;
        }
      );
    });
    
    it("should handle non-existent connection", async () => {
      // Register the tool
      mcpCallServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock callTool to throw a specific error
      mockMcpClientService.callTool.mockRejectedValue(
        new Error("No connection found with ID non-existent-id")
      );
      
      // Create test arguments
      const args = {
        connectionId: "non-existent-id",
        toolName: "remote-tool",
        toolParameters: {},
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidParams);
          assert.ok(error.message.includes("Invalid connection ID"));
          return true;
        }
      );
    });
  });
  
  describe("mcpDisconnectFromServerTool", () => {
    it("should register the tool with the MCP server", () => {
      // Register the tool
      mcpDisconnectFromServerTool(mockMcpServer, mockMcpClientService);
      
      // Verify registration
      assert.strictEqual(mockMcpServer.tool.mock.callCount(), 1);
      const [name, description, schema, processor] = mockMcpServer.tool.mock.calls[0].arguments;
      assert.strictEqual(name, DISCONNECT_TOOL_NAME);
      assert.ok(description.length > 0);
      assert.ok(schema);
      assert.strictEqual(typeof processor, "function");
    });
    
    it("should close an SSE connection successfully", async () => {
      // Mock closeSseConnection to return true
      mockMcpClientService.closeSseConnection.mockReturnValue(true);
      
      // Register the tool
      mcpDisconnectFromServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        connectionId: "test-sse-connection-id",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify closeSseConnection was called
      assert.strictEqual(mockMcpClientService.closeSseConnection.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.closeSseConnection.mock.calls[0].arguments[0], "test-sse-connection-id");
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              message: "SSE Connection closed successfully.",
              connectionId: "test-sse-connection-id",
            }, null, 2),
          },
        ],
      });
    });
    
    it("should close a stdio connection successfully", async () => {
      // Mock closeStdioConnection to return true
      mockMcpClientService.closeStdioConnection.mockReturnValue(true);
      
      // Register the tool
      mcpDisconnectFromServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        connectionId: "test-stdio-connection-id",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify closeStdioConnection was called
      assert.strictEqual(mockMcpClientService.closeStdioConnection.mock.callCount(), 1);
      assert.strictEqual(mockMcpClientService.closeStdioConnection.mock.calls[0].arguments[0], "test-stdio-connection-id");
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              message: "Stdio Connection closed successfully.",
              connectionId: "test-stdio-connection-id",
            }, null, 2),
          },
        ],
      });
    });
    
    it("should throw error for non-existent connection", async () => {
      // Register the tool
      mcpDisconnectFromServerTool(mockMcpServer, mockMcpClientService);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        connectionId: "non-existent-connection-id",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidParams);
          assert.ok(error.message.includes("No active connection found"));
          return true;
        }
      );
    });
  });
  
  describe("writeToFileTool", () => {
    it("should register the tool with the MCP server", () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Verify registration
      assert.strictEqual(mockMcpServer.tool.mock.callCount(), 1);
      const [name, description, schema, processor] = mockMcpServer.tool.mock.calls[0].arguments;
      assert.strictEqual(name, WRITE_FILE_TOOL_NAME);
      assert.ok(description.length > 0);
      assert.ok(schema);
      assert.strictEqual(typeof processor, "function");
    });
    
    it("should write content to a file with utf8 encoding", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments
      const args = {
        filePath: "/allowed/path/test.txt",
        content: "Hello, world!",
        encoding: "utf8",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify secureWriteFile was called
      assert.strictEqual(mockSecureWriteFile.mock.callCount(), 1);
      assert.strictEqual(mockSecureWriteFile.mock.calls[0].arguments[0], "/allowed/path/test.txt");
      assert.strictEqual(mockSecureWriteFile.mock.calls[0].arguments[1], "Hello, world!");
      assert.deepStrictEqual(mockSecureWriteFile.mock.calls[0].arguments[2], ["/allowed/path"]);
      
      // Verify result
      assert.deepStrictEqual(result, {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              message: "Content written to file successfully.",
              filePath: "/allowed/path/test.txt",
            }, null, 2),
          },
        ],
      });
    });
    
    it("should write content to a file with base64 encoding", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Base64 encoding of "Hello, world!"
      const base64Content = "SGVsbG8sIHdvcmxkIQ==";
      
      // Create test arguments
      const args = {
        filePath: "/allowed/path/test.bin",
        content: base64Content,
        encoding: "base64",
      };
      
      // Call the processor function
      const result = await processor(args);
      
      // Verify secureWriteFile was called with decoded content
      assert.strictEqual(mockSecureWriteFile.mock.callCount(), 1);
      assert.strictEqual(mockSecureWriteFile.mock.calls[0].arguments[0], "/allowed/path/test.bin");
      // The content should be decoded from base64
      assert.strictEqual(mockSecureWriteFile.mock.calls[0].arguments[1], Buffer.from(base64Content, "base64").toString("utf8"));
    });
    
    it("should throw error for invalid base64 content", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Create test arguments with invalid base64
      const args = {
        filePath: "/allowed/path/test.bin",
        content: "Not valid base64!@#$%",
        encoding: "base64",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidParams);
          assert.ok(error.message.includes("Invalid base64 content"));
          return true;
        }
      );
    });
    
    it("should throw error when no allowed output paths are configured", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock getAllowedOutputPaths to return empty array
      mockConfigurationManager.getInstance().getAllowedOutputPaths.mockReturnValue([]);
      
      // Create test arguments
      const args = {
        filePath: "/path/to/test.txt",
        content: "Hello, world!",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidRequest);
          assert.ok(error.message.includes("No allowed output paths configured"));
          return true;
        }
      );
    });
    
    it("should handle secureWriteFile errors with path traversal", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock secureWriteFile to throw a specific error
      mockSecureWriteFile.mockRejectedValue(
        new Error("File path is not within the allowed output locations")
      );
      
      // Create test arguments
      const args = {
        filePath: "/path/to/test.txt",
        content: "Hello, world!",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InvalidParams);
          assert.ok(error.message.includes("Security error"));
          return true;
        }
      );
    });
    
    it("should handle other secureWriteFile errors", async () => {
      // Register the tool
      writeToFileTool(mockMcpServer);
      
      // Capture the processor function
      const processor = captureProcessorFunction(mockMcpServer);
      
      // Mock secureWriteFile to throw a generic error
      mockSecureWriteFile.mockRejectedValue(
        new Error("Disk full")
      );
      
      // Create test arguments
      const args = {
        filePath: "/allowed/path/test.txt",
        content: "Hello, world!",
      };
      
      // Call the processor function and expect it to throw
      await assert.rejects(
        async () => await processor(args),
        (error: unknown) => {
          assert.ok(error instanceof McpError);
          const mcpError = error as McpError;
          assert.strictEqual(mcpError.code, ErrorCode.InternalError);
          assert.ok(error.message.includes("Disk full"));
          return true;
        }
      );
    });
  });
});